이 문서는 현재 진행 중인 Middle_Project [Java MVC 기반 프로젝트]에서
전체 계층별 역할과 요청 흐름을 정리한 기술 문서입니다.
구조적 이해와 협업 기준 정립 목적으로 공유드립니다.

1. webapp\WEB-INF\web.xml
    Java EE (Jakarta EE) 기반 웹 애플리케이션이 실행될 때,
    Tomcat 같은 *서블릿 컨테이너*는 자동으로 web.xml 설정 파일을 읽어
    <servlet> 및 <servlet-mapping> 정보를 기반으로
    net.daum.controller.MFrontController 클래스를 서블릿으로 등록하고,
    매핑된 URL 패턴(*.do)에 해당하는 요청을 이 서블릿이 처리하도록 구성합니다.
    
    *서블릿*이란?
      서블릿은 자바로 작성된 클래스입니다.
      하지만 이 클래스는 단독으로 실행되지 않으며,
      Tomcat과 같은 서블릿 컨테이너 안에서만 실행되는 자바 클래스 파일입니다.
      (즉, 서블릿은 웹 서버의 일부로서,
        클라이언트의 웹 요청을 처리하고, 그에 대한 응답을 생성하는 역할을 합니다.)

    *컨테이너*란?
      어떤 구성 요소(객체, 프로그램 등)를 담고 관리하며,
      실행 환경을 제공하는 시스템 또는 구조를 뜻합니다.
      이와 같은 맥락에서, *서블릿 컨테이너*는 서블릿과 JSP를 중간 관리하여
      정상적으로 실행될 수 있도록 환경을 제공하는 역할을 합니다.


2. net.daum.controller.MFrontController
  이 클래스는 web.xml에서 서블릿으로 등록된 Controller 클래스로,
  모든 MVC 패턴에서 주로 사용되는 .do 요청을 수신하고,
  src/daum.properties 설정 파일 내에 
  (예시 : "/board_list.do=execute|net.daum.controller.BoardListController"를
          StringTokenizer(value, "|")로 파싱하여 
          execute와 net.daum.controller.BoardListController로 분리합니다.)
  
  `String exec = st.nextToken();  // execute`
  `String classPath = st.nextToken();  // net.daum.controller.BoardListController`
  (classPath은 String 타입이기 때문에 바로 클래스 파일은 실행이 안되기 때문에
    다음과 같은 3단계 절차를 통해 클래스 실행을 동적으로 처리함.)
      
      사용자가 로그인 요청함 → Controller가 처리함
      처리 결과에 따라 어디로 (Path) 어떻게 (Redirect or Forward) 갈지를 결정해야 함
      이때 단순 문자열(String)로 처리하면 유지보수가 어려우므로
          → ActionForward 클래스가 객체로 결과를 캡슐화해서 전달함
      MFrontController는 이 객체를 기준으로 다음 동작(이동 방식/경로)을 실행함
    
    이후 실제 코드에서는 다음과 같은 방식으로 해당 클래스 파일을 동적으로 로드합니다 :
      -----------------------------------------------------------------------------------
      2-1) 문자열로 전달된 'net.daum.controller.BoardListController'라는 이름을 가진 클래스를 찾아 메모리에 로딩함
          (즉, 실행할 클래스의 설계도를 찾아 JVM 메모리 상에 준비시킴)

        이때, Class.forName() 메서드는 해당 클래스가 존재하지 않거나
        로딩 중 오류가 발생하면 ClassNotFoundException 예외를 발생시킵니다.

      `Class<?> url = Class.forName(classPath);`

      -----------------------------------------------------------------------------------    
      2-2) Class<?> 타입으로 로드된 url객체는 해당 클래스(BoardListController)의 소스 데이터를 
          메모리에 로드한 상태이므로, 이를 인스턴스화하여 실행 가능한 객체로 변환함
          (즉, 설계도를 기반으로 실제 객체를 생성함)

        이때, newInstance() 메서드를 통해 해당 클래스의 기본 생성자를 호출하여
        새로운 인스턴스를 생성합니다.

        해당 인스턴스는 Object 타입 이므로, 이를 Action 인터페이스로 다운캐스팅하여
        Action 타입의 실행 가능한 객체로 변환합니다.

      `action = (Action) url.newInstance();`

      -----------------------------------------------------------------------------------    
      2-3) Action 인터페이스를 구현한 실행 가능한 객체 action이 준비되었으므로,
          준비된 action 객체의 execute() 메서드를 호출하여 실제 로직을 수행하며,  
          이 메서드는 HttpServletRequest(request)와 HttpServletResponse(response) 객체를 인자로 받아  
          사용자 요청을 처리하고, 결과를 forward로 반환합니다.

      `forward = action.execute(request, response);`

      -----------------------------------------------------------------------------------    
      2-4) 이후 net.daum.controller.MFrontController는  
            net.daum.controller.ActionForward 클래스의 forward 객체를 기준으로 다음 동작을 수행합니다:
            public class MFrontController 
              `ActionForward forward = null;`  // Action의 execute()로부터 반환받은 객체

            if forward가 null이 아니면,
              if(forward.isRedirect()) 값을 확인하고,
            
            결과로 받은 forward 객체를 통해 
                if forward가 null이 아니면,
                  if(isRedirect())을 확인하고, 

                  ActionForward 객체는 다음 2가지 정보를 포함함:
                      - 이동 방식: forward인지 redirect인지 여부
                      - 이동 경로: 이동할 JSP 또는 URL 경로
                  
                    이 값이 true이면 → `response.sendRedirect(forward.getPath())`
                                        메서드를 호출하여 *리다이렉트* 방식으로 이동.

                    이 값이 false이면 → `RequestDispatcher.forward(request, response)`
                                        메서드를 호출하여 *포워드* 방식으로 이동.

                *리다이렉트* 방식 : 클라이언트에게 새로운 URL로 이동하라고 지시하는 것
                (즉, 클라이언트가 새로운 요청을 보내도록 유도하는 방식입니다.)

                *포워드* 방식 : 서버 내부에서 요청을 다른 리소스로 전달하는 것입니다
                (즉, 클라이언트는 URL이 변경되지 않고, 서버가 내부적으로 다른 JSP나 서블릿으로 요청을 전달하는 방식입니다.)

                만약 if forward가 null이면
                  `response.sendError(HttpServletResponse.SC_NOT_FOUND);`
                  메서드를 호출하여 404 Not Found 에러를 응답합니다.
          
          
      -----------------------------------------------------------------------------------    
      2-5) 최종 화면 출력 및 응답 종료
          포워드든 리다이렉트든 해당 요청이 완료되면,
          JSP가 클라이언트에게 HTML 결과를 렌더링하여 응답 종료됨

          이후 흐름은 JSP 내 EL, JSTL 등의 표현식을 통해
          request, session 등의 데이터 참조 및 화면 출력으로 이어짐
      
      -----------------------------------------------------------------------------------    
      ※ 요약 : 상기 2-1) ~ 2-4) 의 처리 과정을 정리하면,
            - 사용자가 웹에서 *.do 요청을 보냄
            - MFrontController가 요청을 처리함
            - 그 결과 어디로(Path), 어떻게(*리다이렉트* 또는 *포워드*) 이동할지를 결정해야 함
            - 이 정보를 문자열(String)로 전달하면 유지보수가 어려움
                → 따라서 ActionForward.java 클래스의 forward를 객체로 결과를 캡슐화하여 반환
            - MFrontController는 이 객체를 기반으로  *리다이렉트* / *포워드* 이동 방식 결정 및 수행함
            - 최종적으로 2-5)와 같이 출력합니다.

      ※ 참고 : MFrontController는 모든 *.do 요청을 처리하는 중앙 집중식 컨트롤러로,
               각 요청에 대한 분기 처리를 담당합니다.
      -----------------------------------------------------------------------------------    

3. Service (net.daum.service.MemberServiceImpl)
    비즈니스 로직 중심
    DAO를 호출해서 필요한 데이터 처리 수행
    예외 처리, 조건 분기, 트랜잭션 관리 책임
    
    // net.daum.service.MemberServiceImpl.java
    3-1) *MemberServiceImpl 클래스는 MemberService 인터페이스를 상속* 받아 
          구현하여 idCheck 메서드를 오버라이딩합니다.

    3-2) 클래스 내부에는 다음과 같은 코드가 존재합니다:
              `private MemberDAO memberDao = MemberDAOImpl.getInstance();`
            // 이 코드는 MemberDAOImpl 클래스의 *싱글톤 인스턴스*를 반환받아,
            // MemberDAO 인터페이스 타입으로 업캐스팅 하여 멤버 필드에 저장합니다.
            // MemberServiceImpl 객체가 생성될 때 한 번 실행되며,
            // DAO 객체는 프로그램 전체에서 하나만 생성되어 재사용됩니다.

            *싱글톤 인스턴스* 란? 
              : 클래스의 인스턴스를 오직 하나만 생성해  
                전체 프로그램에서 공유하도록 하는 디자인 패턴임.  
                메모리 낭비를 줄이고, 상태를 일관되게 유지할 수 있음.

    3-3) idCheck 메서드는 매개변수로 전달된 String id 값을 사용하여  
          MemberDAOImpl의 memberDao.idCheck(id) 메서드를 호출합니다.

    3-4) *MemberDAOImpl에서 상속 받은 인터페이스 MemberDAO의 idCheck 메서드는* MyBatis를 통해  
          DB에서 해당 id에 대한 회원 정보를 조회합니다.

    3-5) 조회된 회원 정보가 존재할 경우, MemberDTO 객체로 반환됩니다.

    3-6) 조회된 회원 정보가 없을 경우, null이 반환됩니다.

    3-7) Service에서 반환된 결과는 Controller에서 받아  
        request.setAttribute("member", dto) 형태로 JSP에 전달됩니다.

    *MemberServiceImpl에서 상속 받은 인터페이스 MemberService의 idCheck 메서드*와 
    *MemberDAOImpl에서 상속 받은 인터페이스 MemberDAO의 idCheck 메서드*는 
    ==> 서로 다른 인터페이스와 메서드임.
        (즉, MemberServiceImpl의 idCheck는 비즈니스 로직을 처리하는 메서드이고,
            MemberDAOImpl의 idCheck는 DB 접근을 위한 메서드임).

    [MemberServiceImpl]                                   [MemberDAOImpl]
    ┌─────────────────────────┐                       ┌────────────────────────┐
    │ implements MemberService│   → *업캐스팅* 호출   │ implements MemberDAO   │
    │ idCheck(String id)      │       → 실행됨        │ idCheck(String id)     │
    └─────────────────────────┘                       └────────────────────────┘

      ※ 캐스팅 관계 첨언:
        - MemberServiceImpl은 MemberService 타입으로 *업캐스팅*되어 사용됨  
            → `MemberService memberService = new MemberServiceImpl();`

        - MemberDAOImpl도 MemberDAO 타입으로 *업캐스팅*되어 필드에 저장됨  
            → `MemberDAO memberDao = MemberDAOImpl.getInstance();`  
        
        - 인터페이스를 통해 호출 시 다형성이 적용되어,  
          실제 실행되는 메서드는 구현 클래스의 오버라이딩 메서드(idCheck)임 
        
        - *업캐스팅의* 근거 : 구현체 → 인터페이스로 할당됨     
    
        [인터페이스 계층]
        [MemberService]                   |       [MemberDAO]
        └─ idCheck(String id)             |         └─ idCheck(String id): MemberDTO

        [구현 클래스 계층]
        [MemberServiceImpl]               |     [MemberDAOImpl]
        └─ implements MemberService       |       └─ implements MemberDAO
            └─ idCheck(String id)         |            └─ idCheck(String id)
                  → DAO의 idCheck()       |                → sqlSession.selectOne("member.idCheck", id)
                    호출, 오른쪽과 동일   |                    └─ member.xml <select id="idCheck">
                                          |                          └─ SELECT mem_id FROM member WHERE mem_id = ?
                                          |                                └─ 결과를 MemberDTO로 매핑 후 반환
                                          |                                             └─ request.setAttribute("member", dto);
                                          |                                                   └─ JSP에서 ${member.mem_id} 출력

    [공통된 전체 실행 파이프라인 흐름]
    3-01) JSP에서 사용자 입력(id) 전송 → *.do 요청
        - 예: <form action="login.do" ...>
        - 사용자가 아이디를 입력하고 로그인 요청

    3-02) MFrontController가 요청 분기 후 MemberLoginController 실행
        - web.xml과 daum.properties에 설정된 *.do 요청을 인터페이스 Action 상속받아 구현체로 분기

    3-03) Controller → MemberServiceImpl.idCheck(id) 호출
        - MemberService 인터페이스를 통해 비즈니스 로직 호출

    3-04) ServiceImpl → 내부의 MemberDAOImpl.idCheck(id) 호출
        - DAO 인터페이스를 통해 DB 접근 메서드 호출

    3-05) DAOImpl → MyBatis 통해 "member.idCheck" 쿼리 실행
        - sqlSession.selectOne(...) 실행
        - 내부에서 member.xml의 <select id="idCheck"> 쿼리 매핑

    3-06) DB → 일치하는 회원 레코드 조회 → MemberDTO로 매핑
        - MyBatis가 SELECT 결과를 MemberDTO 객체로 자동 변환

    3-07) DAO → DTO 반환 → Service → Controller
        - 반환된 객체가 다시 상위 계층(Service → Controller)으로 전달됨

    3-08) Controller → request.setAttribute("member", dto)
        - JSP에서 출력할 수 있도록 request scope에 저장

    3-09) Controller → forward.setPath(...jsp) 설정
        - 결과를 출력할 JSP 경로 지정

    3-10) JSP → ${member.mem_id}, ${member.mem_name} 등 출력
        - request에 저장된 member 객체의 필드 출력

4. DAO (net.daum.dao.MemberDAOImpl)
    DB 접근 및 SQL 실행을 담당하는 계층
    - DB 연결 및 종료, 예외 처리
    - MyBatis로 SQL 실행 
    - 조회 결과를 DTO 객체로 매핑하여 반환

    // MyBatis 매핑 파일: member.xml
    <mapper namespace="member">
      <select id="idCheck" resultType="net.daum.dto.MemberDTO">
        SELECT mem_id, mem_pwd, mem_name
        FROM member
        WHERE mem_id = #{mem_id}
      </select>
    </mapper>
    → 위 SQL은 sqlSession.selectOne("member.idCheck", id) 호출 시 실행되며,
      결과는 자동으로 MemberDTO 객체에 매핑됨

    4-1) MemberDAOImpl 클래스는 MemberDAO 인터페이스를 구현함
    4-2) idCheck(String id) 메서드는 MyBatis를 통해 해당 ID로 회원 정보를 조회함
    4-3) 결과가 존재하면 MemberDTO 객체로 반환함

5. DTO (데이터 전달 객체)
    DB 쿼리 결과를 담아 상위 계층에 전달하는 용도의 순수 객체
    - DB나 비즈니스 로직 미포함
    - JavaBean 규약 기반 (getter / setter 포함)
    - View(JSP)에서 표현용으로 사용

    // net.daum.dto.MemberDTO.java
    public class MemberDTO {
      private String mem_id;   // 회원아이디
      private String mem_pwd;  // 비밀번호
      private String mem_name; // 회원이름
      (...생략)
    }

    - 전달 흐름:
      5-1) DAO가 쿼리 결과를 MemberDTO로 반환
      5-2) Service가 해당 객체를 받아 Controller에 전달
      5-3) Controller는 request.setAttribute("member", dto)로 JSP에 전달

    ※ BoardDTO, ZipcodeDTO 등도 동일한 구조로 동작
    ※ DTO는 데이터 구조화와 뷰 분리 책임만 가지며 로직 포함하지 않음

6. JSP (View, 최종 출력)
    사용자에게 보여지는 화면 구성
    전달받은 request 속성값을 HTML과 함께 출력
    주로 JSTL, EL을 사용하여 동적 데이터 처리
    (예: 회원 정보 출력, 게시판 목록 등)

    // WEB-INF/views/member/member_login.jsp
      <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
      <h2>로그인 정보</h2>
      <p>아이디: ${member.mem_id}</p>
      <p>비밀번호: ${member.mem_pwd}</p>
      <p>이름: ${member.mem_name}</p>
      (...생략)


[전체 요약 플로우]
    - 아래 계층은 Java EE 기반의 웹 애플리케이션에서 MVC 패턴을 구현하는 방식에 대한 설명입니다.
    [1] 사용자가 웹브라우저를 통해 *.do 요청 전송
        → [2] MFrontController가 요청을 받아 "daum.properties"를 통해 분기 처리
              → [2-1] Class.forName()으로 Action 클래스 로딩
              → [2-2] Action의 execute(request, response) 실행
                → [3] 해당 요청에 매핑된 Action 클래스 실행 (ex: MemberLoginController)
                    → [4] Action 클래스에서 Service 호출 (ex: MemberServiceImpl)
                        → [5] Service에서 DAO 호출 (ex: MemberDAOImpl)
                            → [6] DAO에서 SQL 실행 후 DTO 생성 (ex: MemberDTO)
                            → [7] DTO 반환 → DAO → Service → Action
                                                               ↓    
                                                               ↓ 
                                                               ↓
                                                      [8] Action에서 request.setAttribute("member", dto)로 JSP에 전달
                                                                                                            ↓
                                                      ↓ [9] MFrontController가 JSP로 포워드   ←   ←   ← 
                                                      → [10] JSP에서 ${member.mem_id}, ${member.mem_name} 등 출력
                                                              ↓
                                                        [11] 최종 HTML 응답 완료
    
    요청 : JSP → *.do 요청 → MFrontController → Action → Service → DAO → DB
    응답 : DB → DTO → Service → Action → request.setAttribute → JSP → HTML 렌더링

------------------------------------------------------------------------------------------------------------------------

[MVC 패턴의 간 분업, 책임 분리표]
| 계층        |    주요 책임                         | 관련 .xml 및 설정 파일          | 역할 설명                                                                                 
|-------------|--------------------------------------|---------------------------------|---------------------------------------------------------------------------------------|
| Controller  |    요청 분기 및 흐름 제어            |   `web.xml`, `daum.properties`  | \*.do 요청을 MFrontController에 연결, `daum.properties`: 요청 URI → 클래스 매핑 설정  |
| Service     |    비즈니스 로직 처리                |     —                           |       —                                                                               |
| DAO         |    DB 쿼리 실행 및 DTO 반환          |  `member.xml` (MyBatis Mapper)  | SQL 구문과 Java 메서드 연결 및 MyBatis에서 SQL 실행 및 DTO 매핑 처리                  |                                  
| DTO         |    계층 간 데이터 전달               |     —                           |       —                                                                               |
| View (JSP)  |    사용자에게 데이터 출력            |  `JSP 파일들 (*.jsp)`           | request에 저장된 DTO 값을 EL/JSTL 등으로 출력                                         |

-------------------------------------------------------------------------------------------------------------------------
피드백과 지적은 언제든 겸허히 수용하겠습니다.
정확성과 명확성을 높이기 위해 지속적으로 개선할 예정입니다.

[끝]
